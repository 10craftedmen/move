# Move runtime library

# A few things that need to be defined in order for this very module to compile
_MoveKWArgsT = global.__move.runtime._MoveKWArgsT;

# -----------------------------------------------------------------------------
# ES5 compatibility

/*if (typeof global == 'undefined' || global.global != global) {
  if (typeof window == 'object')
    window.global = window
  else
    this.global = this
}*/

IS_KNOWN_ES5_HOST = !!(typeof process != 'undefined' &&
                     ((typeof process.versions == 'object' &&
                       process.versions.node) ||
                      process.pid));

if (!IS_KNOWN_ES5_HOST) {
  require './es5_object'
  require './es5_array'
  require './es5_date'
  require './es5_json'
}

# -----------------------------------------------------------------------------
# Additions

require './runtime_string'
require './runtime_date'

# Array.prototype
if (typeof Array.prototype.unique != 'function')
Array.prototype.unique = ^{
  a = [], l = @length
  for (i=0; i<l; ++i) {
    for (j=i+1; j<l; ++j)
      if (this[i] === this[j]) j = ++i
    a.push this[i]
  }
  a
}

# -----------------------------------------------------------------------------
# Constants

# Helper function to define constants
if (Object.defineProperty) {
  defineConstant = ^(obj, name, value){
    Object.defineProperty(obj, name, {
      value: value, writable: false, enumerable: true, configurable: false
    })
  }
} else {
  defineConstant = ^(obj, name, value){ obj[name] = value }
}

# _MoveKWArgsT is a unique object used to test for and prevent tampering with
# keyword arguments
defineConstant(exports, '_MoveKWArgsT', _MoveKWArgsT)

# -----------------------------------------------------------------------------
# Base library functions

# inspect (value) -> string
try {
  # Use an existing implementation if available
  inspect = require('util').inspect
  if (typeof inspect != 'function') throw 1
  exports.inspect = inspect
} catch (e) {
  # Load our implementation
  exports.inspect = require('./runtime_inspect').inspect
}

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype).
 *
 * - `ctor`      -- Constructor function which needs to inherit the prototype.
 * - `superCtor` -- Constructor function to inherit prototype from.
 */
export inherit = ^(ctor, superCtor) {
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: { value: ctor, enumerable: false }
  })
}

# -----------------------------------------------------------------------------
# Single-argument functions (print, repeat, etc)

# Print something (e.g. to a console or other output)
if (typeof console != 'undefined' && console.log) {
  if (typeof window != 'undefined') {
    # In a browser setting we use eval, and eval has the restriction that
    # no code executed can directly reference native objects, thus we wrap
    # console.log in a lambda
    exports.print = ^{
      console.log.apply(console, Array.prototype.slice.call(arguments))
    }
  } else {
    exports.print = console.log
  }
} else {
  # As a last resort, make print a no-op
  exports.print = ^{}
}

# Repeat a `block`...
#
# - `times: N` -- repeat `block` *N* times
#
# If called with shorthand single argument, `block` is repeated until it returns
# a false value
export repeat = ^(times) {
  if (typeof times == 'function') {
    # short-hand call style
    while (true) if (!times()) break
    return
  }
  ^(block){
    if (times != undefined) {
      for (i=0; i<times; ++i) if (block(i) == true) break
    } else {
      while (true) if (!block()) break
    }
  }
}

# Perform a `block` after a delay or date/time
export after = ^(delay, date) {
  if (delay) {
    #if (arguments.)...
    if (typeof delay != 'number')
      throw new TypeError('"delay" argument must be a number')
  } else if (date) {
    if (typeof date == 'string' || typeof date == 'number') {
      date = new Date(date)
      if (isNaN(date.getTime()))
        throw new Error('Invalid date/time passed for "date" argument')
    } else if (typeof date != 'object' || !(date instanceof Date)) {
      throw new TypeError('"date" argument must be a Date object or a string')
    }
    delay = Math.max(0, date.getTime() - (new Date).getTime())
  }
  return ^(block) { setTimeout(block, delay) }
}

# -----------------------------------------------------------------------------
# Keyword variants of common stuff


# JSON value -> string
# JSON {build:value} -> string
# JSON {parse:string} -> value
# JSON.stringify value -> string
# JSON.parse string -> value
_JSON = ^(build, parse) {
  if (build)
    JSON.stringify(build)
  else if (parse)
    JSON.parse(parse)
  else
    throw new TypeError('Expected either "parse" or "build" argument')
}
# To retain compatibility with the standard JSON object interface
_JSON.parse = JSON.parse
_JSON.stringify = JSON.stringify
exports.JSON = _JSON


# Wraps an EventEmitter addListener-style function with keyword arguments and
# shorthand block-style calls
wrapEventEmitter = ^(target, propertyName) {
  _orig = target[propertyName]
  addListener = ^(event, call) {
    if (call) {
      _orig.call(this, event, call)
    } else {
      self = this
      return ^(block) { _orig.call(self, event, block) }
    }
  }
  target[propertyName] = addListener
}

# most things that emit events are based on events.EventEmitter
try { import events } catch(e) {}
if (events && events.EventEmitter) {
  wrapEventEmitter(events.EventEmitter.prototype, 'addListener')
  events.EventEmitter.prototype.on = events.EventEmitter.prototype.addListener
}

# process has a custom implementation
if (typeof process != 'undefined' && typeof process.on == 'function')
  wrapEventEmitter(process, 'on')
