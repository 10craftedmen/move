<h2>Usage</h2>

<p>Move can run in web browsers and &ldquo;interpreters&rdquo; like <a href="http://nodejs.org/">Node.js</a>. Move has been designed so that your code can be run in web browsers and &ldquo;interpreters&rdquo; without any changes &mdash; your code is always running in an ES5 environment with a CommonJS module system.</p>

<h3>Using Move in web browsers</h3>

<p>To run Move in a web browser, you simply include <a href="/move.js">move.js</a>:</p>

<pre><code>&lt;script src="http://movelang.org/move.js"&gt;&lt;/script&gt;
</code></pre>

<p>Move code can then be embedded, which will execute directly after the DOM has loaded:</p>

<pre><code>&lt;script type="text/move"&gt;
print 'Hello worlds!'
&lt;/script&gt;
</code></pre>

<p>If you specify the <code>module</code> attribute, the code defines a module rather than execute the code:</p>

<pre><code>&lt;script type="text/move" module="foo"&gt;
export sayHello = ^{ print 'Hello worlds!' }
&lt;/script&gt;
</code></pre>

<p>It&rsquo;s then possible to <code>import</code> that module from other code:</p>

<pre><code>&lt;script type="text/move"&gt;
import foo
foo.sayHello()
&lt;/script&gt;
</code></pre>

<p>Modules can also be remotely imported:</p>

<pre><code>&lt;script type="text/move" src="foo.mv"&gt;&lt;/script&gt;
</code></pre>

<p>You don&rsquo;t have to care about the order in which you define your modules. The only thing you need to think about is where you execute embedded code.</p>

<h4>Complete example</h4>

<pre><code>&lt;script src="http://movelang.org/move.js"&gt;&lt;/script&gt;
&lt;script type="text/move" module="bar"&gt;
import foo, capitalize
export sayHello = ^(name) {
  print foo.makeHello capitalize name
}
&lt;/script&gt;
&lt;script type="text/move" src="capitalize.mv"&gt;&lt;/script&gt;
&lt;script type="text/move" module="foo"&gt;
export makeHello = ^(name) { 'Hello '+name+'!' }
&lt;/script&gt;
&lt;script type="text/move"&gt;
import bar
bar.sayHello 'worlds'
&lt;/script&gt;
</code></pre>

<p>When the DOM loads, &ldquo;Hello Worlds!&rdquo; is printed to the console.</p>

<p>The Move module itself is available as the global variable <code>move</code> (technically a property of <code>window</code>). This module provides access to preprocessors, the parser &amp; compiler and version info. It also houses the Move runtime library (<code>move.runtime</code>) which can be manipulated. An example of evaluating some Move code:
<samp>&ldquo;function () {
  return print("Hello&rdquo;);
}&ldquo;</samp></p>

<pre><code>move.eval '^{ print "Hello" }'
</code></pre>

<p>This is available in both Move-land <em>and JavaScript-land</em>:</p>

<pre><code>move.eval('^{ print "Hello" }');
</code></pre>

<h3>Using Move in Node.js</h3>

<p>First up; install Move through <a href="http://npmjs.org/">NPM</a>:</p>

<pre><code>npm install move
</code></pre>

<p>Then, <code>require('move');</code> and simply write any module you wish in Move and name the file with a &ldquo;.mv&rdquo; extension. From there everything behaves as normal in Node.js (e.g. defining a foo.mv module and later doing <code>var foo = require('foo');</code> works as expected).</p>

<p>To run Move code directly from the command line, use the <code>move</code> program:</p>

<pre><code>$ move hello.mv
</code></pre>

<p>Note that you can not load Move code directly through <code>node</code> since Node has no knowledge about how to compile Move code. The <code>move</code> program simply registers the Move compiler with Node&rsquo;s module loading system and then loads your module.</p>
